<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.125.5"><link rel="shortcut icon" href=/favicon.ico><title>Microservices and Monoliths: More than you think - More Code, More Problems</title>
<meta name=author content="rrx"><meta property="og:title" content="Microservices and Monoliths: More than you think"><meta name=twitter:title content="Microservices and Monoliths: More than you think"><meta property="og:type" content="article"><meta property="og:url" content="https://rrx.github.io/posts/2024-04-28-microservices/"><meta property="og:description" content="When evaluating a complex software system, consider the key architectural characteristic of the contrast between microservices and monoliths. Many articles have been written on the difference between these two, but they often focus on just a the obvious. I&rsquo;d like to dig a little deeper in this article. If you’re not quite clear on the distinction there’s a great article on the AWS blog about it."><meta name=twitter:description content="When evaluating a complex software system, consider the key architectural characteristic of the contrast between microservices and monoliths. Many articles have been written on the difference between these two, but they often focus on just a the obvious. I&rsquo;d like to dig a little deeper in this article. If you’re not quite clear on the distinction there’s a great article on the AWS blog about it."><meta property="og:image" content="https://rrx.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rrx.github.io/img/og.png"><meta property="article:published_time" content="2024-04-28T09:31:12-08:00"><meta property="article:modified_time" content="2024-04-28T09:31:12-08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://rrx.github.io/assets/css/fuji.min.css></head><body data-theme=dark data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://rrx.github.io/>More Code, More Problems</a>
<span class=title-sub>A software engineering blog</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://rrx.github.io/posts/2024-04-28-microservices/>Microservices and Monoliths: More than you think</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2024-04-28</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1560 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;No tag</span></div><div class="post-content markdown-body"><p>When evaluating a complex software system, consider the key architectural characteristic of the contrast between microservices and monoliths. Many articles have been written on the difference between these two, but they often focus on just a the obvious. I&rsquo;d like to dig a little deeper in this article. If you’re not quite clear on the distinction there’s a great article on the <a href=https://aws.amazon.com/compare/the-difference-between-monolithic-and-microservices-architecture/ target=_blank>AWS blog about it.</a></p><figure><img src=./microservices.jpg alt="battleship and container ship (sd)" loading=lazy><figcaption>battleship and container ship (sd)</figcaption></figure><p>When we talk about the choice between microservices and monoliths, it’s presented as an either or. But most organizations have some combination of the two. A legacy monolith with more recent work in microservices. Most articles typically disparage monoliths and evangelize microservices. The bias isn’t helpful to someone who faced with the decision.</p><p>I’d like to point out some situations where a developer may encounter this decision. Consider the following:</p><ul><li>The microservice is no longer so micro, and it’s starting to encounter some issues. Is it time to break it up into smaller services?</li><li>You want to add a new feature, do you add it to one of the existing services, or do you create a new service?</li><li>A microservice seems to be the source of a number of bugs or outages, are there some architectural choices we can consider to improve the situation?</li></ul><p>Let’s dig into some reasons why you might want to consider one or the other, even if you work in an organization that’s all in on microservices. The principles apply whenever you have a growing and evolving code base. The faster things are moving, the more likely you will need to make these decisions. The automatic reflex to build a new service every time you can’t find a place for something will multiply your problems. Alternatively, how can you make the case to your manager that you need to split your service? Let’s get into some principles I have used to help make this decision for myself and the teams I have worked with.</p><h2 id=when-to-consider-a-monolith>When to consider a monolith</h2><p>Monoliths aren’t all bad. In fact there are some compelling advantages. Most of the added complexity can be handled through modularization (the modular monolith) and enforced with tooling or language features.</p><p>Just to open up the possibilities here. A monolith might actually look like a microservice, but that microservice, spans multiple domains, or it handles a variety of requests. While it might be nice to split these out, keeping them together isn’t always a bad idea.</p><p>Here are some reasons to consider a monolith:</p><ul><li><p><strong>Longer Release Cycles</strong>: If your team works with extended release cycles, say every two weeks or more, and there’s no imminent shift towards continuous delivery, a monolith might serve you better. Consider the QA process: testing a single, cohesive artifact or appliance can be far simpler and more straightforward than wrestling with multiple microservices. The integrated nature of a monolith ensures that all components interact within the same environment, significantly simplifying integration testing.</p></li><li><p><strong>Standardized Tech Stack</strong>: Monoliths shine in environments with a uniform tech stack. Leveraging the full feature set of a single programming language to manage different components of your application can offer a robust composition layer, avoiding the overhead of remote procedure calls typical in microservices architectures. Moreover, if your development team isn&rsquo;t huge or highly skilled, having a single stack reduces the learning curve and fosters better understanding and collaboration among team members. Languages that support strong module or library systems can effectively encapsulate and segregate functionality within a monolith, maintaining clarity and modularity without the operational complexity of microservices.</p></li><li><p><strong>Performance Critical Software</strong>: For applications where performance is paramount, such as those handling low-latency requests (think of financial transactions) , the potential performance gains of a monolith can be a game-changer. When all parts of an application run on a single system, the network overhead of microservices can almost be eliminated, potentially unlocking significant gains in processing speed and resource management.</p></li><li><p><strong>Simplicity in Development</strong>: Often a company starts with a monolithic architecture and only migrates to microservices when the complexity of their operations necessitates it. For startups focused on getting a viable product to market swiftly, the monolith offers fewer moving parts and a lower barrier to initial development. Debugging is more straightforward when you don’t need to trace issues across network boundaries, and the overall system architecture is easier to grasp for new developers.</p></li><li><p><strong>Rapid Development</strong>
In the fast paced startup world, speed can make it or break it. A monolithic architecture allows for rapid development, and simplifies the design space. When it comes to speed, sometimes less is more. The ability to develop quickly and deploy immediately without the considerations of managing multiple services can be an advantage.</p></li><li><p><strong>When High Availability Is Not a Requirement</strong>: Not every application needs to be available 24/7. For desktop software or applications in use solely during business hours, the high availability that microservices offer might not justify the added complexity. In such cases, if a monolithic architecture can meet you availability needs effectively, there’s no need for the added complexity of multiple services.</p></li></ul><h2 id=when-to-consider-microservices>When to consider microservices</h2><p>Considering microservices goes beyond a decision at the start of a new project. It&rsquo;s something to consider as your services grow and evolve. The are often considered when a service has become too difficult to extend or maintain. Microservices isn&rsquo;t the only answer, here are some reasons you might want to condsider splitting up your monolith into microservices.</p><ul><li><p><strong>Managing Stack or Language Incompatibilities</strong>: Microservices are great for integrating across diverse technologies. If your stack is getting a bit wild, a little python here, some golang there, all wrapped up with multiple targets in a Dockerfile and duck taped with bash scripts, then you might want to consider splitting it up, and setting up each project independently. This can help developers avoid the temptation to continue feeding your Frankenstein monster. Splitting it up will allow you to define clear API boundaries, and let your teams focus on their strengths.</p></li><li><p><strong>Isolating Critical Components</strong>: Separating services according to their criticality ensures that less critical components can fail without cascading effects on entire system. This architectural choice helps in resource allocation, preventing non-essential services from starving out critical ones.</p></li><li><p><strong>Lifecycle Differences</strong>: How frequently your services chances can be a factor to consider. Microservices are ideal for isolating parts of a system that change at different rates. Services that require frequent updates or have a large number of upstream dependencies can be isolated to reduce the risk of introducing errors into stable parts of the system that change infrequently.</p></li><li><p><strong>Stable and Compatible APIs</strong>: Microservices can be used to define and enforce API compatibility using common RPC Frameworks. You can use this trick with monoliths as well, but it&rsquo;s more commonly seen in microservices. Tools like gRPC, Thrift, and GraphQL not only facilitate building and consuming APIs but through some additional tooling, also ensure compatibility across different versions. They help manage the contract between services, preventing breaking changes and maintaining consistency.</p></li><li><p><strong>API Usage Patterns</strong>: Microservices enable tailored scaling and optimization strategies based on specific usage patterns such as high throughput or low latency requirements. This makes them particularly advantageous in systems where performance criteria vary significantly between components.</p></li><li><p><strong>Data and Compliance Requirements</strong>: In scenarios with stringent data handling or compliance regulations like GDPR or FedRAMP, microservices can allow for clear segregation of data, aligning architecture with compliance needs.</p></li><li><p><strong>Reduce Complexity</strong>: While microservices are often associated with increased complexity, they can also be used to manage complexity. Decomposing your system into self-contained services can actually help encapsulate difficult parts of the system. This can reduce cognitive load when reasoning about the system as a whole.</p></li><li><p><strong>Deploy Contention</strong>: In highly active development environments where deployment pipelines become congested, microservices offer a way out by allowing individual teams to deploy their services independently. In my experience, this is often the final straw that forces a decision to split a service up.</p></li><li><p><strong>Blast Radius</strong>: The concept of &lsquo;blast radius&rsquo; refers to the extent of impact a failure can have on the wider system. Microservices limit this by isolating failures to individual services. This isn&rsquo;t always the case of course. Microservices are also well known for causing cascading failures. A well architected system can avoid these problems.</p></li><li><p><strong>Cleanly Separated Domains</strong>: Microservices encourage the separation of business capabilities into distinct domains, each with its own database and service environment. This is closely related the <a href=https://en.wikipedia.org/wiki/Domain-driven_design target=_blank>Domain Driven Design (DDD)</a>, which benefits from microservices by aligning service boundaries with domain boundaries.</p></li></ul><h2 id=conclusion>Conclusion</h2><p>I hope this article gave you a some things to think about when considering how services compose together. These are just the considerations I have thought about, and I&rsquo;m sure there&rsquo;s more. It&rsquo;s worth considering both options. What will work for you depends entirely on your situation. The fun part of software is having the power and flexibility to build things just right.</p><p>Here are some thoughts to end with:</p><ul><li>Not every situation requires Google level architecture, if you find yourself working on a monolith, remember, consider the advantages to doing so.</li><li>If you think your microservice has gotten too big, it might be just fine, and you can leave it as is.</li><li>If everyone complains about how long it takes to get code deployed, splitting up the code could help, or bankrupt your company.</li></ul><p>No easy answers, just lots to think about. Thanks for reading.</p></div></article></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/rrx target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/ryansadler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#when-to-consider-a-monolith>When to consider a monolith</a></li><li><a href=#when-to-consider-microservices>When to consider microservices</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>RSS</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/rrx target=_blank><span>GitHub</span></a></li><li><a href=https://www.linkedin.com/in/ryansadler/ target=_blank><span>LinkedIn</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#when-to-consider-a-monolith>When to consider a monolith</a></li><li><a href=#when-to-consider-microservices>When to consider microservices</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><p>Unless otherwise noted, the content of this site is copyrighted by the author<a rel=license href target=_blank></a>.</p><span>&copy; 2022-2024
<a href=https://rrx.github.io/>rrx</a>
| <a href=https://github.com/rrx/blog>Source code</a>
| Powered by
<a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script type=text/javascript>!function(){var t,n,e=window.rudderanalytics=window.rudderanalytics||[];e.methods=["load","page","track","identify","alias","group","ready","reset","getAnonymousId","setAnonymousId","getUserId","getUserTraits","getGroupId","getGroupTraits","startSession","endSession"],e.factory=function(t){return function(){e.push([t].concat(Array.prototype.slice.call(arguments)))}};for(t=0;t<e.methods.length;t++)n=e.methods[t],e[n]=e.factory(n);e.loadJS=function(){var s,n=document.createElement("script");n.type="text/javascript",n.async=!0,n.src="https://cdn.rudderlabs.com/v1.1/rudder-analytics.min.js",s=document.getElementsByTagName("script")[0],s.parentNode.insertBefore(n,s)},e.loadJS(),e.load("2N99gtSBfrZoErnE6LvtLrqnazN","https://aifuzzryajdxl.dataplane.rudderstack.com"),e.page()}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D2TXLR3QQ4"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D2TXLR3QQ4")</script><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script><script>renderMathInElement(document.querySelector("div.content"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>