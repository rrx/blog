<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on More Code, More Problems</title><link>https://rrx.github.io/posts/</link><description>Recent content in Posts on More Code, More Problems</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 28 Apr 2024 09:31:12 -0800</lastBuildDate><atom:link href="https://rrx.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Microservices and Monoliths: More than you think</title><link>https://rrx.github.io/posts/2024-04-28-microservices/</link><pubDate>Sun, 28 Apr 2024 09:31:12 -0800</pubDate><guid>https://rrx.github.io/posts/2024-04-28-microservices/</guid><description>&lt;p>When evaluating a complex software system, we must consider the architectural choice between microservices and monoliths. Many articles have been written on the difference between these two, but they mostly focus on the obvious. I&amp;rsquo;d like to dig a little deeper in this article. If youâ€™re not quite clear on the distinction, &lt;a href="https://aws.amazon.com/compare/the-difference-between-monolithic-and-microservices-architecture/" target="_blank">here is a great article.&lt;/a>&lt;/p></description></item><item><title>New code base, where to start?</title><link>https://rrx.github.io/posts/2023-03-15-new-code-base/</link><pubDate>Wed, 15 Mar 2023 19:41:02 -0700</pubDate><guid>https://rrx.github.io/posts/2023-03-15-new-code-base/</guid><description>&lt;p>At work, I&amp;rsquo;ve started working on a new code base. This has me thinking about the best way do this.
Code can sometimes be a real pain. You aren&amp;rsquo;t just inheriting all the good stuff, you also take on
all of the short cuts and half finished features that make up the technical debt of the project. A
new code base is a package, you don&amp;rsquo;t get to choose only the good parts. So where to start?&lt;/p></description></item><item><title>Hot-Reloading like it's 1972</title><link>https://rrx.github.io/posts/2023-02-13-hotreloading/</link><pubDate>Mon, 13 Feb 2023 00:00:00 -0800</pubDate><guid>https://rrx.github.io/posts/2023-02-13-hotreloading/</guid><description>&lt;p>TL;DR Here&amp;rsquo;s a sketch of a solution for hot-reloading that I hope will bring some greater flow to my
development process. Present day solutions are more about shipping the final product, than they are
about enjoying the process of coding. Hot-reloading is one of those features that once you have it,
you just don&amp;rsquo;t want to live without it again. So let&amp;rsquo;s get hot-reloading like it&amp;rsquo;s 1972!&lt;/p></description></item><item><title>Technical Debt, A Systems Level Problem</title><link>https://rrx.github.io/posts/2023-02-05-tech-debt/</link><pubDate>Sun, 05 Feb 2023 19:33:40 -0800</pubDate><guid>https://rrx.github.io/posts/2023-02-05-tech-debt/</guid><description>&lt;p>I just finished reading &lt;a href="https://dl.acm.org/doi/book/10.5555/3364312" target="_blank">&amp;ldquo;Managing Technical Debt&amp;rdquo;&lt;/a>, and while it provides some excellent ideas on the topic, I felt like it was missing something vital. The book focuses primarily on the technical side of the problem. The human factors however, are just as important. Not including them in our assessments is a major reason why we have so much trouble assessing the true cost of our technical debt. I think this omission is common in the industry, and I think it&amp;rsquo;s time to change that.&lt;/p></description></item></channel></rss>